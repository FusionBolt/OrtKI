namespace OrtKISharp;

public partial class OrtKI
{
//This file is automatically generated from the onnx def files via tools/gen_operators.py.
public static Tensor Abs(Tensor X){
var _tensor = ortki_Abs(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Acos(Tensor input){
var _tensor = ortki_Acos(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Acosh(Tensor input){
var _tensor = ortki_Acosh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Add(Tensor A, Tensor B){
var _tensor = ortki_Add(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor And(Tensor A, Tensor B){
var _tensor = ortki_And(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor ArgMax(Tensor data, long axis, long keepdims, long select_last_index){
var _tensor = ortki_ArgMax(data.Handle, axis, keepdims, select_last_index);
return new Tensor(_tensor);
}
public static Tensor ArgMin(Tensor data, long axis, long keepdims, long select_last_index){
var _tensor = ortki_ArgMin(data.Handle, axis, keepdims, select_last_index);
return new Tensor(_tensor);
}
public static Tensor Asin(Tensor input){
var _tensor = ortki_Asin(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Asinh(Tensor input){
var _tensor = ortki_Asinh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Atan(Tensor input){
var _tensor = ortki_Atan(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Atanh(Tensor input){
var _tensor = ortki_Atanh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor AveragePool(Tensor X, String auto_pad, long ceil_mode, long count_include_pad, long[] kernel_shape, long[] pads, long[] strides){
var _tensor = ortki_AveragePool(X.Handle, auto_pad, ceil_mode, count_include_pad, kernel_shape, kernel_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor BitShift(Tensor X, Tensor Y, String direction){
var _tensor = ortki_BitShift(X.Handle, Y.Handle, direction);
return new Tensor(_tensor);
}
public static Tensor Cast(Tensor input, long to){
var _tensor = ortki_Cast(input.Handle, to);
return new Tensor(_tensor);
}
public static Tensor Ceil(Tensor X){
var _tensor = ortki_Ceil(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Celu(Tensor X, float alpha){
var _tensor = ortki_Celu(X.Handle, alpha);
return new Tensor(_tensor);
}
public static Tensor Clip(Tensor input, Tensor min, Tensor max){
var _tensor = ortki_Clip(input.Handle, min.Handle, max.Handle);
return new Tensor(_tensor);
}
public static Tensor Compress(Tensor input, Tensor condition, long axis){
var _tensor = ortki_Compress(input.Handle, condition.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor Concat(Tensor[] inputs, long axis){
var _tensor = ortki_Concat(inputs.Select(x=>x.Handle).ToArray(), inputs.Length, axis);
return new Tensor(_tensor);
}
public static Tensor ConcatFromSequence(Tensor[] input_sequence, long axis, long new_axis){
var _tensor = ortki_ConcatFromSequence(input_sequence.Select(x=>x.Handle).ToArray(), input_sequence.Length, axis, new_axis);
return new Tensor(_tensor);
}
public static Tensor Conv(Tensor X, Tensor W, Tensor B, String auto_pad, long[] dilations, long group, long[] kernel_shape, long[] pads, long[] strides){
var _tensor = ortki_Conv(X.Handle, W.Handle, B.Handle, auto_pad, dilations, dilations.Length, group, kernel_shape, kernel_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor ConvInteger(Tensor x, Tensor w, Tensor x_zero_point, Tensor w_zero_point, String auto_pad, long[] dilations, long group, long[] kernel_shape, long[] pads, long[] strides){
var _tensor = ortki_ConvInteger(x.Handle, w.Handle, x_zero_point.Handle, w_zero_point.Handle, auto_pad, dilations, dilations.Length, group, kernel_shape, kernel_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor ConvTranspose(Tensor X, Tensor W, Tensor B, String auto_pad, long[] dilations, long group, long[] kernel_shape, long[] output_padding, long[] output_shape, long[] pads, long[] strides){
var _tensor = ortki_ConvTranspose(X.Handle, W.Handle, B.Handle, auto_pad, dilations, dilations.Length, group, kernel_shape, kernel_shape.Length, output_padding, output_padding.Length, output_shape, output_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor Cos(Tensor input){
var _tensor = ortki_Cos(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Cosh(Tensor input){
var _tensor = ortki_Cosh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor CumSum(Tensor x, Tensor axis, long exclusive, long reverse){
var _tensor = ortki_CumSum(x.Handle, axis.Handle, exclusive, reverse);
return new Tensor(_tensor);
}
public static Tensor DepthToSpace(Tensor input, long blocksize, String mode){
var _tensor = ortki_DepthToSpace(input.Handle, blocksize, mode);
return new Tensor(_tensor);
}
public static Tensor DequantizeLinear(Tensor x, Tensor x_scale, Tensor x_zero_point, long axis){
var _tensor = ortki_DequantizeLinear(x.Handle, x_scale.Handle, x_zero_point.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor Det(Tensor X){
var _tensor = ortki_Det(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Div(Tensor A, Tensor B){
var _tensor = ortki_Div(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor[] Dropout(Tensor data, Tensor ratio, Tensor training_mode, long seed){
var _tensor = ortki_Dropout(data.Handle, ratio.Handle, training_mode.Handle, seed);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor[] DynamicQuantizeLinear(Tensor x){
var _tensor = ortki_DynamicQuantizeLinear(x.Handle);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor Einsum(Tensor[] Inputs, String equation){
var _tensor = ortki_Einsum(Inputs.Select(x=>x.Handle).ToArray(), Inputs.Length, equation);
return new Tensor(_tensor);
}
public static Tensor Elu(Tensor X, float alpha){
var _tensor = ortki_Elu(X.Handle, alpha);
return new Tensor(_tensor);
}
public static Tensor Equal(Tensor A, Tensor B){
var _tensor = ortki_Equal(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor Erf(Tensor input){
var _tensor = ortki_Erf(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Exp(Tensor input){
var _tensor = ortki_Exp(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Expand(Tensor input, Tensor shape){
var _tensor = ortki_Expand(input.Handle, shape.Handle);
return new Tensor(_tensor);
}
public static Tensor EyeLike(Tensor input, long dtype, long k){
var _tensor = ortki_EyeLike(input.Handle, dtype, k);
return new Tensor(_tensor);
}
public static Tensor Flatten(Tensor input, long axis){
var _tensor = ortki_Flatten(input.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor Floor(Tensor X){
var _tensor = ortki_Floor(X.Handle);
return new Tensor(_tensor);
}
public static Tensor[] GRU(Tensor X, Tensor W, Tensor R, Tensor B, Tensor sequence_lens, Tensor initial_h, float[] activation_alpha, float[] activation_beta, String[] activations, float clip, String direction, long hidden_size, long layout, long linear_before_reset){
var _tensor = ortki_GRU(X.Handle, W.Handle, R.Handle, B.Handle, sequence_lens.Handle, initial_h.Handle, activation_alpha, activation_alpha.Length, activation_beta, activation_beta.Length, activations, activations.Length, clip, direction, hidden_size, layout, linear_before_reset);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor Gather(Tensor data, Tensor indices, long axis){
var _tensor = ortki_Gather(data.Handle, indices.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor GatherElements(Tensor data, Tensor indices, long axis){
var _tensor = ortki_GatherElements(data.Handle, indices.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor GatherND(Tensor data, Tensor indices, long batch_dims){
var _tensor = ortki_GatherND(data.Handle, indices.Handle, batch_dims);
return new Tensor(_tensor);
}
public static Tensor Gemm(Tensor A, Tensor B, Tensor C, float alpha, float beta, long transA, long transB){
var _tensor = ortki_Gemm(A.Handle, B.Handle, C.Handle, alpha, beta, transA, transB);
return new Tensor(_tensor);
}
public static Tensor GlobalAveragePool(Tensor X){
var _tensor = ortki_GlobalAveragePool(X.Handle);
return new Tensor(_tensor);
}
public static Tensor GlobalLpPool(Tensor X, long p){
var _tensor = ortki_GlobalLpPool(X.Handle, p);
return new Tensor(_tensor);
}
public static Tensor GlobalMaxPool(Tensor X){
var _tensor = ortki_GlobalMaxPool(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Greater(Tensor A, Tensor B){
var _tensor = ortki_Greater(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor GreaterOrEqual(Tensor A, Tensor B){
var _tensor = ortki_GreaterOrEqual(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor HardSigmoid(Tensor X, float alpha, float beta){
var _tensor = ortki_HardSigmoid(X.Handle, alpha, beta);
return new Tensor(_tensor);
}
public static Tensor HardSwish(Tensor X){
var _tensor = ortki_HardSwish(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Hardmax(Tensor input, long axis){
var _tensor = ortki_Hardmax(input.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor Identity(Tensor input){
var _tensor = ortki_Identity(input.Handle);
return new Tensor(_tensor);
}
public static Tensor InstanceNormalization(Tensor input, Tensor scale, Tensor B, float epsilon){
var _tensor = ortki_InstanceNormalization(input.Handle, scale.Handle, B.Handle, epsilon);
return new Tensor(_tensor);
}
public static Tensor IsInf(Tensor X, long detect_negative, long detect_positive){
var _tensor = ortki_IsInf(X.Handle, detect_negative, detect_positive);
return new Tensor(_tensor);
}
public static Tensor IsNaN(Tensor X){
var _tensor = ortki_IsNaN(X.Handle);
return new Tensor(_tensor);
}
public static Tensor LRN(Tensor X, float alpha, float beta, float bias, long size){
var _tensor = ortki_LRN(X.Handle, alpha, beta, bias, size);
return new Tensor(_tensor);
}
public static Tensor[] LSTM(Tensor X, Tensor W, Tensor R, Tensor B, Tensor sequence_lens, Tensor initial_h, Tensor initial_c, Tensor P, float[] activation_alpha, float[] activation_beta, String[] activations, float clip, String direction, long hidden_size, long input_forget, long layout){
var _tensor = ortki_LSTM(X.Handle, W.Handle, R.Handle, B.Handle, sequence_lens.Handle, initial_h.Handle, initial_c.Handle, P.Handle, activation_alpha, activation_alpha.Length, activation_beta, activation_beta.Length, activations, activations.Length, clip, direction, hidden_size, input_forget, layout);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor LeakyRelu(Tensor X, float alpha){
var _tensor = ortki_LeakyRelu(X.Handle, alpha);
return new Tensor(_tensor);
}
public static Tensor Less(Tensor A, Tensor B){
var _tensor = ortki_Less(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor LessOrEqual(Tensor A, Tensor B){
var _tensor = ortki_LessOrEqual(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor Log(Tensor input){
var _tensor = ortki_Log(input.Handle);
return new Tensor(_tensor);
}
public static Tensor LogSoftmax(Tensor input, long axis){
var _tensor = ortki_LogSoftmax(input.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor LpNormalization(Tensor input, long axis, long p){
var _tensor = ortki_LpNormalization(input.Handle, axis, p);
return new Tensor(_tensor);
}
public static Tensor LpPool(Tensor X, String auto_pad, long[] kernel_shape, long p, long[] pads, long[] strides){
var _tensor = ortki_LpPool(X.Handle, auto_pad, kernel_shape, kernel_shape.Length, p, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor MatMul(Tensor A, Tensor B){
var _tensor = ortki_MatMul(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor MatMulInteger(Tensor A, Tensor B, Tensor a_zero_point, Tensor b_zero_point){
var _tensor = ortki_MatMulInteger(A.Handle, B.Handle, a_zero_point.Handle, b_zero_point.Handle);
return new Tensor(_tensor);
}
public static Tensor Max(Tensor[] data_0){
var _tensor = ortki_Max(data_0.Select(x=>x.Handle).ToArray(), data_0.Length);
return new Tensor(_tensor);
}
public static Tensor[] MaxPool(Tensor X, String auto_pad, long ceil_mode, long[] dilations, long[] kernel_shape, long[] pads, long storage_order, long[] strides){
var _tensor = ortki_MaxPool(X.Handle, auto_pad, ceil_mode, dilations, dilations.Length, kernel_shape, kernel_shape.Length, pads, pads.Length, storage_order, strides, strides.Length);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor MaxRoiPool(Tensor X, Tensor rois, long[] pooled_shape, float spatial_scale){
var _tensor = ortki_MaxRoiPool(X.Handle, rois.Handle, pooled_shape, pooled_shape.Length, spatial_scale);
return new Tensor(_tensor);
}
public static Tensor MaxUnpool(Tensor X, Tensor I, Tensor output_shape, long[] kernel_shape, long[] pads, long[] strides){
var _tensor = ortki_MaxUnpool(X.Handle, I.Handle, output_shape.Handle, kernel_shape, kernel_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor Mean(Tensor[] data_0){
var _tensor = ortki_Mean(data_0.Select(x=>x.Handle).ToArray(), data_0.Length);
return new Tensor(_tensor);
}
public static Tensor MeanVarianceNormalization(Tensor X, long[] axes){
var _tensor = ortki_MeanVarianceNormalization(X.Handle, axes, axes.Length);
return new Tensor(_tensor);
}
public static Tensor Min(Tensor[] data_0){
var _tensor = ortki_Min(data_0.Select(x=>x.Handle).ToArray(), data_0.Length);
return new Tensor(_tensor);
}
public static Tensor Mod(Tensor A, Tensor B, long fmod){
var _tensor = ortki_Mod(A.Handle, B.Handle, fmod);
return new Tensor(_tensor);
}
public static Tensor Mul(Tensor A, Tensor B){
var _tensor = ortki_Mul(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor Multinomial(Tensor input, long dtype, long sample_size, float seed){
var _tensor = ortki_Multinomial(input.Handle, dtype, sample_size, seed);
return new Tensor(_tensor);
}
public static Tensor Neg(Tensor X){
var _tensor = ortki_Neg(X.Handle);
return new Tensor(_tensor);
}
public static Tensor NegativeLogLikelihoodLoss(Tensor input, Tensor target, Tensor weight, long ignore_index, String reduction){
var _tensor = ortki_NegativeLogLikelihoodLoss(input.Handle, target.Handle, weight.Handle, ignore_index, reduction);
return new Tensor(_tensor);
}
public static Tensor NonMaxSuppression(Tensor boxes, Tensor scores, Tensor max_output_boxes_per_class, Tensor iou_threshold, Tensor score_threshold, long center_point_box){
var _tensor = ortki_NonMaxSuppression(boxes.Handle, scores.Handle, max_output_boxes_per_class.Handle, iou_threshold.Handle, score_threshold.Handle, center_point_box);
return new Tensor(_tensor);
}
public static Tensor NonZero(Tensor X){
var _tensor = ortki_NonZero(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Not(Tensor X){
var _tensor = ortki_Not(X.Handle);
return new Tensor(_tensor);
}
public static Tensor OneHot(Tensor indices, Tensor depth, Tensor values, long axis){
var _tensor = ortki_OneHot(indices.Handle, depth.Handle, values.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor Or(Tensor A, Tensor B){
var _tensor = ortki_Or(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor PRelu(Tensor X, Tensor slope){
var _tensor = ortki_PRelu(X.Handle, slope.Handle);
return new Tensor(_tensor);
}
public static Tensor Pad(Tensor data, Tensor pads, Tensor constant_value, String mode){
var _tensor = ortki_Pad(data.Handle, pads.Handle, constant_value.Handle, mode);
return new Tensor(_tensor);
}
public static Tensor Pow(Tensor X, Tensor Y){
var _tensor = ortki_Pow(X.Handle, Y.Handle);
return new Tensor(_tensor);
}
public static Tensor QLinearConv(Tensor x, Tensor x_scale, Tensor x_zero_point, Tensor w, Tensor w_scale, Tensor w_zero_point, Tensor y_scale, Tensor y_zero_point, Tensor B, String auto_pad, long[] dilations, long group, long[] kernel_shape, long[] pads, long[] strides){
var _tensor = ortki_QLinearConv(x.Handle, x_scale.Handle, x_zero_point.Handle, w.Handle, w_scale.Handle, w_zero_point.Handle, y_scale.Handle, y_zero_point.Handle, B.Handle, auto_pad, dilations, dilations.Length, group, kernel_shape, kernel_shape.Length, pads, pads.Length, strides, strides.Length);
return new Tensor(_tensor);
}
public static Tensor QLinearMatMul(Tensor a, Tensor a_scale, Tensor a_zero_point, Tensor b, Tensor b_scale, Tensor b_zero_point, Tensor y_scale, Tensor y_zero_point){
var _tensor = ortki_QLinearMatMul(a.Handle, a_scale.Handle, a_zero_point.Handle, b.Handle, b_scale.Handle, b_zero_point.Handle, y_scale.Handle, y_zero_point.Handle);
return new Tensor(_tensor);
}
public static Tensor QuantizeLinear(Tensor x, Tensor y_scale, Tensor y_zero_point, long axis){
var _tensor = ortki_QuantizeLinear(x.Handle, y_scale.Handle, y_zero_point.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor[] RNN(Tensor X, Tensor W, Tensor R, Tensor B, Tensor sequence_lens, Tensor initial_h, float[] activation_alpha, float[] activation_beta, String[] activations, float clip, String direction, long hidden_size, long layout){
var _tensor = ortki_RNN(X.Handle, W.Handle, R.Handle, B.Handle, sequence_lens.Handle, initial_h.Handle, activation_alpha, activation_alpha.Length, activation_beta, activation_beta.Length, activations, activations.Length, clip, direction, hidden_size, layout);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor RandomNormal(long dtype, float mean, float scale, float seed, long[] shape){
var _tensor = ortki_RandomNormal(dtype, mean, scale, seed, shape, shape.Length);
return new Tensor(_tensor);
}
public static Tensor RandomNormalLike(Tensor input, long dtype, float mean, float scale, float seed){
var _tensor = ortki_RandomNormalLike(input.Handle, dtype, mean, scale, seed);
return new Tensor(_tensor);
}
public static Tensor RandomUniform(long dtype, float high, float low, float seed, long[] shape){
var _tensor = ortki_RandomUniform(dtype, high, low, seed, shape, shape.Length);
return new Tensor(_tensor);
}
public static Tensor RandomUniformLike(Tensor input, long dtype, float high, float low, float seed){
var _tensor = ortki_RandomUniformLike(input.Handle, dtype, high, low, seed);
return new Tensor(_tensor);
}
public static Tensor Range(Tensor start, Tensor limit, Tensor delta){
var _tensor = ortki_Range(start.Handle, limit.Handle, delta.Handle);
return new Tensor(_tensor);
}
public static Tensor Reciprocal(Tensor X){
var _tensor = ortki_Reciprocal(X.Handle);
return new Tensor(_tensor);
}
public static Tensor ReduceL1(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceL1(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceL2(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceL2(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceLogSum(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceLogSum(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceLogSumExp(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceLogSumExp(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceMax(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceMax(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceMean(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceMean(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceMin(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceMin(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceProd(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceProd(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor ReduceSum(Tensor data, Tensor axes, long keepdims, long noop_with_empty_axes){
var _tensor = ortki_ReduceSum(data.Handle, axes.Handle, keepdims, noop_with_empty_axes);
return new Tensor(_tensor);
}
public static Tensor ReduceSumSquare(Tensor data, long[] axes, long keepdims){
var _tensor = ortki_ReduceSumSquare(data.Handle, axes, axes.Length, keepdims);
return new Tensor(_tensor);
}
public static Tensor Relu(Tensor X){
var _tensor = ortki_Relu(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Reshape(Tensor data, Tensor shape, long allowzero){
var _tensor = ortki_Reshape(data.Handle, shape.Handle, allowzero);
return new Tensor(_tensor);
}
public static Tensor ReverseSequence(Tensor input, Tensor sequence_lens, long batch_axis, long time_axis){
var _tensor = ortki_ReverseSequence(input.Handle, sequence_lens.Handle, batch_axis, time_axis);
return new Tensor(_tensor);
}
public static Tensor RoiAlign(Tensor X, Tensor rois, Tensor batch_indices, String mode, long output_height, long output_width, long sampling_ratio, float spatial_scale){
var _tensor = ortki_RoiAlign(X.Handle, rois.Handle, batch_indices.Handle, mode, output_height, output_width, sampling_ratio, spatial_scale);
return new Tensor(_tensor);
}
public static Tensor Round(Tensor X){
var _tensor = ortki_Round(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Scatter(Tensor data, Tensor indices, Tensor updates, long axis){
var _tensor = ortki_Scatter(data.Handle, indices.Handle, updates.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor ScatterElements(Tensor data, Tensor indices, Tensor updates, long axis){
var _tensor = ortki_ScatterElements(data.Handle, indices.Handle, updates.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor ScatterND(Tensor data, Tensor indices, Tensor updates){
var _tensor = ortki_ScatterND(data.Handle, indices.Handle, updates.Handle);
return new Tensor(_tensor);
}
public static Tensor Selu(Tensor X, float alpha, float gamma){
var _tensor = ortki_Selu(X.Handle, alpha, gamma);
return new Tensor(_tensor);
}
public static Tensor SequenceAt(Tensor[] input_sequence, Tensor position){
var _tensor = ortki_SequenceAt(input_sequence.Select(x=>x.Handle).ToArray(), input_sequence.Length, position.Handle);
return new Tensor(_tensor);
}
public static Tensor SequenceConstruct(Tensor[] inputs){
var _tensor = ortki_SequenceConstruct(inputs.Select(x=>x.Handle).ToArray(), inputs.Length);
return new Tensor(_tensor);
}
public static Tensor SequenceEmpty(long dtype){
var _tensor = ortki_SequenceEmpty(dtype);
return new Tensor(_tensor);
}
public static Tensor SequenceErase(Tensor[] input_sequence, Tensor position){
var _tensor = ortki_SequenceErase(input_sequence.Select(x=>x.Handle).ToArray(), input_sequence.Length, position.Handle);
return new Tensor(_tensor);
}
public static Tensor SequenceInsert(Tensor[] input_sequence, Tensor tensor, Tensor position){
var _tensor = ortki_SequenceInsert(input_sequence.Select(x=>x.Handle).ToArray(), input_sequence.Length, tensor.Handle, position.Handle);
return new Tensor(_tensor);
}
public static Tensor SequenceLength(Tensor[] input_sequence){
var _tensor = ortki_SequenceLength(input_sequence.Select(x=>x.Handle).ToArray(), input_sequence.Length);
return new Tensor(_tensor);
}
public static Tensor Shape(Tensor data){
var _tensor = ortki_Shape(data.Handle);
return new Tensor(_tensor);
}
public static Tensor Shrink(Tensor input, float bias, float lambd){
var _tensor = ortki_Shrink(input.Handle, bias, lambd);
return new Tensor(_tensor);
}
public static Tensor Sigmoid(Tensor X){
var _tensor = ortki_Sigmoid(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Sign(Tensor input){
var _tensor = ortki_Sign(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Sin(Tensor input){
var _tensor = ortki_Sin(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Sinh(Tensor input){
var _tensor = ortki_Sinh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Size(Tensor data){
var _tensor = ortki_Size(data.Handle);
return new Tensor(_tensor);
}
public static Tensor Slice(Tensor data, Tensor starts, Tensor ends, Tensor axes, Tensor steps){
var _tensor = ortki_Slice(data.Handle, starts.Handle, ends.Handle, axes.Handle, steps.Handle);
return new Tensor(_tensor);
}
public static Tensor Softmax(Tensor input, long axis){
var _tensor = ortki_Softmax(input.Handle, axis);
return new Tensor(_tensor);
}
public static Tensor[] SoftmaxCrossEntropyLoss(Tensor scores, Tensor labels, Tensor weights, long ignore_index, String reduction){
var _tensor = ortki_SoftmaxCrossEntropyLoss(scores.Handle, labels.Handle, weights.Handle, ignore_index, reduction);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor Softplus(Tensor X){
var _tensor = ortki_Softplus(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Softsign(Tensor input){
var _tensor = ortki_Softsign(input.Handle);
return new Tensor(_tensor);
}
public static Tensor SpaceToDepth(Tensor input, long blocksize){
var _tensor = ortki_SpaceToDepth(input.Handle, blocksize);
return new Tensor(_tensor);
}
public static Tensor SplitToSequence(Tensor input, Tensor split, long axis, long keepdims){
var _tensor = ortki_SplitToSequence(input.Handle, split.Handle, axis, keepdims);
return new Tensor(_tensor);
}
public static Tensor Sqrt(Tensor X){
var _tensor = ortki_Sqrt(X.Handle);
return new Tensor(_tensor);
}
public static Tensor Squeeze(Tensor data, Tensor axes){
var _tensor = ortki_Squeeze(data.Handle, axes.Handle);
return new Tensor(_tensor);
}
public static Tensor StringNormalizer(Tensor X, String case_change_action, long is_case_sensitive, String locale, String[] stopwords){
var _tensor = ortki_StringNormalizer(X.Handle, case_change_action, is_case_sensitive, locale, stopwords, stopwords.Length);
return new Tensor(_tensor);
}
public static Tensor Sub(Tensor A, Tensor B){
var _tensor = ortki_Sub(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor Sum(Tensor[] data_0){
var _tensor = ortki_Sum(data_0.Select(x=>x.Handle).ToArray(), data_0.Length);
return new Tensor(_tensor);
}
public static Tensor Tan(Tensor input){
var _tensor = ortki_Tan(input.Handle);
return new Tensor(_tensor);
}
public static Tensor Tanh(Tensor input){
var _tensor = ortki_Tanh(input.Handle);
return new Tensor(_tensor);
}
public static Tensor TfIdfVectorizer(Tensor X, long max_gram_length, long max_skip_count, long min_gram_length, String mode, long[] ngram_counts, long[] ngram_indexes, long[] pool_int64s, String[] pool_strings, float[] weights){
var _tensor = ortki_TfIdfVectorizer(X.Handle, max_gram_length, max_skip_count, min_gram_length, mode, ngram_counts, ngram_counts.Length, ngram_indexes, ngram_indexes.Length, pool_int64s, pool_int64s.Length, pool_strings, pool_strings.Length, weights, weights.Length);
return new Tensor(_tensor);
}
public static Tensor ThresholdedRelu(Tensor X, float alpha){
var _tensor = ortki_ThresholdedRelu(X.Handle, alpha);
return new Tensor(_tensor);
}
public static Tensor Tile(Tensor input, Tensor repeats){
var _tensor = ortki_Tile(input.Handle, repeats.Handle);
return new Tensor(_tensor);
}
public static Tensor[] TopK(Tensor X, Tensor K, long axis, long largest, long sorted){
var _tensor = ortki_TopK(X.Handle, K.Handle, axis, largest, sorted);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor Transpose(Tensor data, long[] perm){
var _tensor = ortki_Transpose(data.Handle, perm, perm.Length);
return new Tensor(_tensor);
}
public static Tensor Trilu(Tensor input, Tensor k, long upper){
var _tensor = ortki_Trilu(input.Handle, k.Handle, upper);
return new Tensor(_tensor);
}
public static Tensor[] Unique(Tensor X, long axis, long sorted){
var _tensor = ortki_Unique(X.Handle, axis, sorted);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor Unsqueeze(Tensor data, Tensor axes){
var _tensor = ortki_Unsqueeze(data.Handle, axes.Handle);
return new Tensor(_tensor);
}
public static Tensor Upsample(Tensor X, Tensor scales, String mode){
var _tensor = ortki_Upsample(X.Handle, scales.Handle, mode);
return new Tensor(_tensor);
}
public static Tensor Where(Tensor condition, Tensor X, Tensor Y){
var _tensor = ortki_Where(condition.Handle, X.Handle, Y.Handle);
return new Tensor(_tensor);
}
public static Tensor Xor(Tensor A, Tensor B){
var _tensor = ortki_Xor(A.Handle, B.Handle);
return new Tensor(_tensor);
}
public static Tensor ArrayFeatureExtractor(Tensor X, Tensor Y){
var _tensor = ortki_ArrayFeatureExtractor(X.Handle, Y.Handle);
return new Tensor(_tensor);
}
public static Tensor Binarizer(Tensor X, float threshold){
var _tensor = ortki_Binarizer(X.Handle, threshold);
return new Tensor(_tensor);
}
public static Tensor CastMap(Tensor X, String cast_to, String map_form, long max_map){
var _tensor = ortki_CastMap(X.Handle, cast_to, map_form, max_map);
return new Tensor(_tensor);
}
public static Tensor CategoryMapper(Tensor X, long[] cats_int64s, String[] cats_strings, long default_int64, String default_string){
var _tensor = ortki_CategoryMapper(X.Handle, cats_int64s, cats_int64s.Length, cats_strings, cats_strings.Length, default_int64, default_string);
return new Tensor(_tensor);
}
public static Tensor DictVectorizer(Tensor X, long[] int64_vocabulary, String[] string_vocabulary){
var _tensor = ortki_DictVectorizer(X.Handle, int64_vocabulary, int64_vocabulary.Length, string_vocabulary, string_vocabulary.Length);
return new Tensor(_tensor);
}
public static Tensor FeatureVectorizer(Tensor[] X, long[] inputdimensions){
var _tensor = ortki_FeatureVectorizer(X.Select(x=>x.Handle).ToArray(), X.Length, inputdimensions, inputdimensions.Length);
return new Tensor(_tensor);
}
public static Tensor Imputer(Tensor X, float[] imputed_value_floats, long[] imputed_value_int64s, float replaced_value_float, long replaced_value_int64){
var _tensor = ortki_Imputer(X.Handle, imputed_value_floats, imputed_value_floats.Length, imputed_value_int64s, imputed_value_int64s.Length, replaced_value_float, replaced_value_int64);
return new Tensor(_tensor);
}
public static Tensor LabelEncoder(Tensor X, float default_float, long default_int64, String default_string, float[] keys_floats, long[] keys_int64s, String[] keys_strings, float[] values_floats, long[] values_int64s, String[] values_strings){
var _tensor = ortki_LabelEncoder(X.Handle, default_float, default_int64, default_string, keys_floats, keys_floats.Length, keys_int64s, keys_int64s.Length, keys_strings, keys_strings.Length, values_floats, values_floats.Length, values_int64s, values_int64s.Length, values_strings, values_strings.Length);
return new Tensor(_tensor);
}
public static Tensor[] LinearClassifier(Tensor X, long[] classlabels_ints, String[] classlabels_strings, float[] coefficients, float[] intercepts, long multi_class, String post_transform){
var _tensor = ortki_LinearClassifier(X.Handle, classlabels_ints, classlabels_ints.Length, classlabels_strings, classlabels_strings.Length, coefficients, coefficients.Length, intercepts, intercepts.Length, multi_class, post_transform);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor LinearRegressor(Tensor X, float[] coefficients, float[] intercepts, String post_transform, long targets){
var _tensor = ortki_LinearRegressor(X.Handle, coefficients, coefficients.Length, intercepts, intercepts.Length, post_transform, targets);
return new Tensor(_tensor);
}
public static Tensor Normalizer(Tensor X, String norm){
var _tensor = ortki_Normalizer(X.Handle, norm);
return new Tensor(_tensor);
}
public static Tensor OneHotEncoder(Tensor X, long[] cats_int64s, String[] cats_strings, long zeros){
var _tensor = ortki_OneHotEncoder(X.Handle, cats_int64s, cats_int64s.Length, cats_strings, cats_strings.Length, zeros);
return new Tensor(_tensor);
}
public static Tensor[] SVMClassifier(Tensor X, long[] classlabels_ints, String[] classlabels_strings, float[] coefficients, float[] kernel_params, String kernel_type, String post_transform, float[] prob_a, float[] prob_b, float[] rho, float[] support_vectors, long[] vectors_per_class){
var _tensor = ortki_SVMClassifier(X.Handle, classlabels_ints, classlabels_ints.Length, classlabels_strings, classlabels_strings.Length, coefficients, coefficients.Length, kernel_params, kernel_params.Length, kernel_type, post_transform, prob_a, prob_a.Length, prob_b, prob_b.Length, rho, rho.Length, support_vectors, support_vectors.Length, vectors_per_class, vectors_per_class.Length);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor SVMRegressor(Tensor X, float[] coefficients, float[] kernel_params, String kernel_type, long n_supports, long one_class, String post_transform, float[] rho, float[] support_vectors){
var _tensor = ortki_SVMRegressor(X.Handle, coefficients, coefficients.Length, kernel_params, kernel_params.Length, kernel_type, n_supports, one_class, post_transform, rho, rho.Length, support_vectors, support_vectors.Length);
return new Tensor(_tensor);
}
public static Tensor Scaler(Tensor X, float[] offset, float[] scale){
var _tensor = ortki_Scaler(X.Handle, offset, offset.Length, scale, scale.Length);
return new Tensor(_tensor);
}
public static Tensor[] TreeEnsembleClassifier(Tensor X, float[] base_values, long[] class_ids, long[] class_nodeids, long[] class_treeids, float[] class_weights, long[] classlabels_int64s, String[] classlabels_strings, long[] nodes_falsenodeids, long[] nodes_featureids, float[] nodes_hitrates, long[] nodes_missing_value_tracks_true, String[] nodes_modes, long[] nodes_nodeids, long[] nodes_treeids, long[] nodes_truenodeids, float[] nodes_values, String post_transform){
var _tensor = ortki_TreeEnsembleClassifier(X.Handle, base_values, base_values.Length, class_ids, class_ids.Length, class_nodeids, class_nodeids.Length, class_treeids, class_treeids.Length, class_weights, class_weights.Length, classlabels_int64s, classlabels_int64s.Length, classlabels_strings, classlabels_strings.Length, nodes_falsenodeids, nodes_falsenodeids.Length, nodes_featureids, nodes_featureids.Length, nodes_hitrates, nodes_hitrates.Length, nodes_missing_value_tracks_true, nodes_missing_value_tracks_true.Length, nodes_modes, nodes_modes.Length, nodes_nodeids, nodes_nodeids.Length, nodes_treeids, nodes_treeids.Length, nodes_truenodeids, nodes_truenodeids.Length, nodes_values, nodes_values.Length, post_transform);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor TreeEnsembleRegressor(Tensor X, String aggregate_function, float[] base_values, long n_targets, long[] nodes_falsenodeids, long[] nodes_featureids, float[] nodes_hitrates, long[] nodes_missing_value_tracks_true, String[] nodes_modes, long[] nodes_nodeids, long[] nodes_treeids, long[] nodes_truenodeids, float[] nodes_values, String post_transform, long[] target_ids, long[] target_nodeids, long[] target_treeids, float[] target_weights){
var _tensor = ortki_TreeEnsembleRegressor(X.Handle, aggregate_function, base_values, base_values.Length, n_targets, nodes_falsenodeids, nodes_falsenodeids.Length, nodes_featureids, nodes_featureids.Length, nodes_hitrates, nodes_hitrates.Length, nodes_missing_value_tracks_true, nodes_missing_value_tracks_true.Length, nodes_modes, nodes_modes.Length, nodes_nodeids, nodes_nodeids.Length, nodes_treeids, nodes_treeids.Length, nodes_truenodeids, nodes_truenodeids.Length, nodes_values, nodes_values.Length, post_transform, target_ids, target_ids.Length, target_nodeids, target_nodeids.Length, target_treeids, target_treeids.Length, target_weights, target_weights.Length);
return new Tensor(_tensor);
}
public static Tensor ZipMap(Tensor X, long[] classlabels_int64s, String[] classlabels_strings){
var _tensor = ortki_ZipMap(X.Handle, classlabels_int64s, classlabels_int64s.Length, classlabels_strings, classlabels_strings.Length);
return new Tensor(_tensor);
}
public static Tensor[] Adagrad(Tensor R, Tensor T, Tensor inputs, float decay_factor, float epsilon, float norm_coefficient){
var _tensor = ortki_Adagrad(R.Handle, T.Handle, inputs.Handle, decay_factor, epsilon, norm_coefficient);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor[] Adam(Tensor R, Tensor T, Tensor inputs, float alpha, float beta, float epsilon, float norm_coefficient, float norm_coefficient_post){
var _tensor = ortki_Adam(R.Handle, T.Handle, inputs.Handle, alpha, beta, epsilon, norm_coefficient, norm_coefficient_post);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor[] Gradient(Tensor[] Inputs, String[] xs, String y, String[] zs){
var _tensor = ortki_Gradient(Inputs.Select(x=>x.Handle).ToArray(), Inputs.Length, xs, xs.Length, y, zs, zs.Length);
return new TensorSeq(_tensor).ToTensorArray();
}
public static Tensor[] Momentum(Tensor R, Tensor T, Tensor inputs, float alpha, float beta, String mode, float norm_coefficient){
var _tensor = ortki_Momentum(R.Handle, T.Handle, inputs.Handle, alpha, beta, mode, norm_coefficient);
return new TensorSeq(_tensor).ToTensorArray();
}
}